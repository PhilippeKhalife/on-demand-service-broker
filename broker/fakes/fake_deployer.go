// Copyright (C) 2016-Present Pivotal Software, Inc. All rights reserved.
// This program and the accompanying materials are made available under the terms of the under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.

// This file was generated by counterfeiter
package fakes

import (
	"log"
	"sync"

	"github.com/pivotal-cf/on-demand-service-broker/broker"
)

type FakeDeployer struct {
	CreateStub        func(deploymentName, planID string, requestParams map[string]interface{}, boshContextID string, logger *log.Logger) (int, []byte, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		deploymentName string
		planID         string
		requestParams  map[string]interface{}
		boshContextID  string
		logger         *log.Logger
	}
	createReturns struct {
		result1 int
		result2 []byte
		result3 error
	}
	createReturnsOnCall map[int]struct {
		result1 int
		result2 []byte
		result3 error
	}
	UpdateStub        func(deploymentName, planID string, requestParams map[string]interface{}, previousPlanID *string, boshContextID string, logger *log.Logger) (int, []byte, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		deploymentName string
		planID         string
		requestParams  map[string]interface{}
		previousPlanID *string
		boshContextID  string
		logger         *log.Logger
	}
	updateReturns struct {
		result1 int
		result2 []byte
		result3 error
	}
	updateReturnsOnCall map[int]struct {
		result1 int
		result2 []byte
		result3 error
	}
	UpgradeStub        func(deploymentName, planID string, previousPlanID *string, boshContextID string, logger *log.Logger) (int, []byte, error)
	upgradeMutex       sync.RWMutex
	upgradeArgsForCall []struct {
		deploymentName string
		planID         string
		previousPlanID *string
		boshContextID  string
		logger         *log.Logger
	}
	upgradeReturns struct {
		result1 int
		result2 []byte
		result3 error
	}
	upgradeReturnsOnCall map[int]struct {
		result1 int
		result2 []byte
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDeployer) Create(deploymentName string, planID string, requestParams map[string]interface{}, boshContextID string, logger *log.Logger) (int, []byte, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		deploymentName string
		planID         string
		requestParams  map[string]interface{}
		boshContextID  string
		logger         *log.Logger
	}{deploymentName, planID, requestParams, boshContextID, logger})
	fake.recordInvocation("Create", []interface{}{deploymentName, planID, requestParams, boshContextID, logger})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(deploymentName, planID, requestParams, boshContextID, logger)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.createReturns.result1, fake.createReturns.result2, fake.createReturns.result3
}

func (fake *FakeDeployer) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeDeployer) CreateArgsForCall(i int) (string, string, map[string]interface{}, string, *log.Logger) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].deploymentName, fake.createArgsForCall[i].planID, fake.createArgsForCall[i].requestParams, fake.createArgsForCall[i].boshContextID, fake.createArgsForCall[i].logger
}

func (fake *FakeDeployer) CreateReturns(result1 int, result2 []byte, result3 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDeployer) CreateReturnsOnCall(i int, result1 int, result2 []byte, result3 error) {
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 int
			result2 []byte
			result3 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDeployer) Update(deploymentName string, planID string, requestParams map[string]interface{}, previousPlanID *string, boshContextID string, logger *log.Logger) (int, []byte, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		deploymentName string
		planID         string
		requestParams  map[string]interface{}
		previousPlanID *string
		boshContextID  string
		logger         *log.Logger
	}{deploymentName, planID, requestParams, previousPlanID, boshContextID, logger})
	fake.recordInvocation("Update", []interface{}{deploymentName, planID, requestParams, previousPlanID, boshContextID, logger})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(deploymentName, planID, requestParams, previousPlanID, boshContextID, logger)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.updateReturns.result1, fake.updateReturns.result2, fake.updateReturns.result3
}

func (fake *FakeDeployer) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeDeployer) UpdateArgsForCall(i int) (string, string, map[string]interface{}, *string, string, *log.Logger) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].deploymentName, fake.updateArgsForCall[i].planID, fake.updateArgsForCall[i].requestParams, fake.updateArgsForCall[i].previousPlanID, fake.updateArgsForCall[i].boshContextID, fake.updateArgsForCall[i].logger
}

func (fake *FakeDeployer) UpdateReturns(result1 int, result2 []byte, result3 error) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDeployer) UpdateReturnsOnCall(i int, result1 int, result2 []byte, result3 error) {
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 int
			result2 []byte
			result3 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDeployer) Upgrade(deploymentName string, planID string, previousPlanID *string, boshContextID string, logger *log.Logger) (int, []byte, error) {
	fake.upgradeMutex.Lock()
	ret, specificReturn := fake.upgradeReturnsOnCall[len(fake.upgradeArgsForCall)]
	fake.upgradeArgsForCall = append(fake.upgradeArgsForCall, struct {
		deploymentName string
		planID         string
		previousPlanID *string
		boshContextID  string
		logger         *log.Logger
	}{deploymentName, planID, previousPlanID, boshContextID, logger})
	fake.recordInvocation("Upgrade", []interface{}{deploymentName, planID, previousPlanID, boshContextID, logger})
	fake.upgradeMutex.Unlock()
	if fake.UpgradeStub != nil {
		return fake.UpgradeStub(deploymentName, planID, previousPlanID, boshContextID, logger)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.upgradeReturns.result1, fake.upgradeReturns.result2, fake.upgradeReturns.result3
}

func (fake *FakeDeployer) UpgradeCallCount() int {
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	return len(fake.upgradeArgsForCall)
}

func (fake *FakeDeployer) UpgradeArgsForCall(i int) (string, string, *string, string, *log.Logger) {
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	return fake.upgradeArgsForCall[i].deploymentName, fake.upgradeArgsForCall[i].planID, fake.upgradeArgsForCall[i].previousPlanID, fake.upgradeArgsForCall[i].boshContextID, fake.upgradeArgsForCall[i].logger
}

func (fake *FakeDeployer) UpgradeReturns(result1 int, result2 []byte, result3 error) {
	fake.UpgradeStub = nil
	fake.upgradeReturns = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDeployer) UpgradeReturnsOnCall(i int, result1 int, result2 []byte, result3 error) {
	fake.UpgradeStub = nil
	if fake.upgradeReturnsOnCall == nil {
		fake.upgradeReturnsOnCall = make(map[int]struct {
			result1 int
			result2 []byte
			result3 error
		})
	}
	fake.upgradeReturnsOnCall[i] = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDeployer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeDeployer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ broker.Deployer = new(FakeDeployer)
